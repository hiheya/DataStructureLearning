# 数据结构与算法打卡-Day03


## 长度最小的子数组



### 1. leetcode 209题 长度最小的子数组

原题链接: [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续**
>
> **子数组**
>
> `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
> 
>
>  
>
> **示例 1：**
>
> ```tex
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> ```
>
> **示例 2：**
>
> ```tex
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> ```
>
> **示例 3：**
>
> ```tex
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `1 <= target <= 10^9`
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^5`

题解：

```java
// 长度最小的子数组
// 给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。
public int minSubArrayLen(int target, int[] nums) {
    // 使用滑动窗口
    // 初始化左右指针及当前和
    int left = 0;
    int right = 0;
    int sum = 0;
    // 最小长度设置成一个很大的值
    int minLen = Integer.MAX_VALUE;

    while(right < nums.length) {
        // 把右指针指向得元素加起来
        sum += nums[right];
        // 当sum 大于等于 target时说明存在子数组
        while(sum >= target) {
            // 把length存起来，因为是返回长度 所以需要存的是 索引之差再加一
            minLen = Math.min(minLen, right - left + 1);
            // 左指针继续右移同时 sum也要减去最左边元素，看是否存在长度更小得子数组，
            sum -= nums[left];
            left++;
        }
        // 右指针始终向右移动一位
        right++;
    }
    // 看minLen是否被重新赋值，如果未被重新赋值说明没有最小子数组，否则返回最小子数组长度
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```

> 这里使用的是滑动窗口方法。左右指针定义了一个窗口，我们通过移动右指针来扩大窗口，当窗口内的元素和大于等于目标值时，我们尝试通过移动左指针来缩小窗口，以找到满足条件的最小长度。

### 1.2 leetcode 904题 水果成篮

原题链接： [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。
>
> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
>
> - 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
> - 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
> - 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
>
> 给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。
>
>  
>
> **示例 1：**
>
> ```tex
> 输入：fruits = [1,2,1]
> 输出：3
> 解释：可以采摘全部 3 棵树。
> ```
>
> **示例 2：**
>
> ```tex
> 输入：fruits = [0,1,2,2]
> 输出：3
> 解释：可以采摘 [1,2,2] 这三棵树。
> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
> ```
>
> **示例 3：**
>
> ```tex
> 输入：fruits = [1,2,3,2,2]
> 输出：4
> 解释：可以采摘 [2,3,2,2] 这四棵树。
> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
> ```
>
> **示例 4：**
>
> ```tex
> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
> 输出：5
> 解释：可以采摘 [1,2,1,1,2] 这五棵树。
> ```
>
>  
>
> **提示：**
>
> - `1 <= fruits.length <= 10^5`
> - `0 <= fruits[i] < fruits.length`

题解：

```java
public int totalFruit(int[] fruits) {
    // 左右指针
    int left = 0;
    int right = 0;
    // 篮子
    Map<Integer, Integer> basket = new HashMap<>();
    // 最大水果数
    int maxFruits = 0;
    // 当右指针没有遍历完数组，继续循环
    while(right < fruits.length) {
        // 这里就相当于把水果放进篮子的过程，key为水果类型 确保其唯一性，value 为该类型水果的数量。相同类型的水果进来 数量+1；
        basket.put(fruits[right], basket.getOrDefault(fruits[right], 0) + 1);
        // 当篮子中的水果种类大于2时，尝试缩小窗口以找到最大水果数；
        while (basket.size() > 2) {
            // 将左指针指向的水果从篮子中拿出去，一次拿一个
            basket.put(fruits[left], basket.get(fruits[left]) - 1);
            // 如果篮子里面已经没有左指针指向的水果类型了，就将这个类型的水果从篮子里面移除
            if (basket.get(fruits[left]) == 0) {
                basket.remove(fruits[left]);
            }
            // 左指针右移，寻找下一个最大水果数
            left++;
        }
        // 每次循环完都更新一次最大水果数
        maxFruits = Math.max(maxFruits, right - left + 1);
        // 右指针始终向右移
        right++;
    }
    return maxFruits;
}
```

> 解题思路： 使用两个指针，一个左指针和一个右指针，来表示当前的窗口。我们还使用一个哈希表来表示当前篮子中的水果类型和数量。 
>
> 
>
> 我们从左到右遍历数组，每次将右指针指向的水果放入篮子中。如果篮子中的水果种类超过2种，我们就尝试缩小窗口，也就是将左指针指向的水果从篮子中移除，直到篮子中的水果种类再次变为2种。在这个过程中，我们每次都更新可以收集的水果的最大数量。 



### 1.3 leetcode 76题 最小覆盖字串

原题链接： [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。
>
>  
>
> **注意：**
>
> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
>
>  
>
> **示例 1：**
>
> ```tex
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> 解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
> ```
>
> **示例 2：**
>
> ```tex
> 输入：s = "a", t = "a"
> 输出："a"
> 解释：整个字符串 s 是最小覆盖子串。
> ```
>
> **示例 3:**
>
> ```tex
> 输入: s = "a", t = "aa"
> 输出: ""
> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，
> 因此没有符合条件的子字符串，返回空字符串。
> ```
>
>  
>
> **提示：**
>
> - `m == s.length`
> - `n == t.length`
> - `1 <= m, n <= 10^5`
> - `s` 和 `t` 由英文字母组成

题解： 

```java

```

